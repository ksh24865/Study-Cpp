## Chapter 10 연산자 오버로딩 1
### 10-1 연산자 오버로딩의 이해와 유형

연산자 오버로딩
- 'operator' 키워드와 '연산자'를 묶어서 함수의 이름을 정의하면, 함수의 이름을 이용한 함수의 호출뿐만 아니라, 연산자를 이용한 함수의 호출도 허용해 주겠다. 
- 객체를 피연산자로 사용한 연산자의 이름 앞에 operator 라는 이름을 붙여서 완성되는 이름의 함수를 호출하겠다.
- 멤버함수와 전역함수, 두 가지 방법으로 오버로딩 가능하다.
- 멤버함수 기반으로 오버로딩 된 함수가 전역함수 기반으로 오버로딩 된 함수보다 우선시되어 호출된다.

연산자를 오버로딩 하는데 있어서의 주의사항
1. 본래의 의도를 벗어난 형태의 연산자 오버로딩은 좋지 않다.
2. 연산자의 우선순위와 결합성은 바뀌지 않는다.
3. 매개변수의 디폴트 값 설정이 불가능하다.
4. 연산자의 순수 기능까지 빼앗을 수는 없다.

### 10-2 단항 연산자의 오버로딩
피연산자가 두 개인 이항 연산자와 피연산자가 하나인 단항 연산자

증가, 감소 연산자의 오버로딩
- 멤버함수, 전역함수 두 가지 방법 가능.
- 키워드 int를 이용해서 후위연산에 대한 함수를 전위연산에 대한 함수와 구분하고 있다. (int는 구분하기 위한 목적!)

반환형에서의 const 선언과 const 객체
- 반환형에서 const 선언하면 함수의 반환으로 인해서 생성되는 임시객체를 const 객체로 생성.
- 이 객체를 대상으로는 const 로 선언되지 않은 멤버함수의 호출이 불가능.

### 10-3 교환법칙 문제의 해결
멤버함수 형태로 오버로딩한 경우 연산의 교환법칙이 성립안함
-> 전역함수의 형태로 오버로딩하여 해결.

### 10-4 cout, cin 그리고 endl의 정체
cout(cin)은 ostream(istream) 클래스의 객체.
ostream(istream)은 이름공간 std 안에 선언되어 있으며, 이의 사용을 위해서는 헤더파일 <iostream>을 포함해야 함.
